# -*- coding: utf-8 -*-
"""Text RPG.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PFyuKKF9Ak3SqmaLdw5Mpola9noMLDsU
"""

import os
import sys
import csv

import pyttsx3
import speech_recognition as sr

import random as r



#pip install pyttsx3 SpeechRecognition
#pip install pocketsphinx
#pip install pyaudio
#pip install pyinstaller

#pyinstaller --onefile Text_Monsters.py


# Get the directory path of the code file
script_path = os.path.abspath(sys.argv[0])
current_dir = os.path.dirname(script_path)
game_dir = os.path.join(current_dir, 'Game Data')
if (not os.path.exists(game_dir)):
  current_dir = os.path.dirname(current_dir)
  game_dir = os.path.join(current_dir, 'Game Data')

if (not os.path.exists(game_dir)):
  raise "no file"


message_buffer = ""
engine = pyttsx3.init()

speech_mode_out = False
menu_speech_out = False
speech_mode_in  = False



TAS_MODE = False
TAS_Index = [0, 3, 1, 1]
TAS_Log = "\n"
TAS_Log_template = "Mode {:>2}: Got {} {} with {} battles left and {} attempts left.  "
#    TAS PLAN FOR SOLVED GAME:
# Initialization
# Train back and forth across route 1
# Town sync
# Fly to viridian and attempt viridian forrest with town sync, fly back to viridian after to retry
# Fly to Pewter and attempt gym with town sync, fly back to pewter after to retry


def get_TAS_input():
  global TAS_Index
  # All loops are in reverse order
  start_loop = [2, 2, 4]
  battle_loop = [4, 3, 0, 4, 2, 1, 1]
  town_sync_loop = [4, 3, 0, 4, 2, 1, 9, 1, 9]
  # Get hard values to set up phases
  game_phase, counter, battle_counter, attempts_counter = TAS_Index
  if (battle_counter == 0):
    attempts_counter -= 1
  if (attempts_counter == 0):
    game_phase += 1
  if (game_phase == 0):
    counter -= 1
    num = start_loop[counter]
  TAS_Index = game_phase, counter, battle_counter, attempts_counter
  return num




# TODO: Features:
#  [X] Add exp yield
#  [X] Add a continue after battle
#  [X] Change percent health to real health
#  [X] Mark if attacker is foe or not in print messages
#  [X] Handle if one pokemon faints in battle
#  [X] Add Summary for towns/battle
#  [X] Add Switch for towns/battle/faint
#  [X] Add catch chance
#  [X] Handle Evolution
#  [X] Add boss encounters
#  [X] Add Badges
#  [X] Add Fly to fast travel
#  [X] Add Save
#  [X] Add Load
#  [X] Add Exit
#  [X] Restrict League to need all 8 badges
#  [X] Fix so exp doesn't go to dead mons
#  [X] Add underground tunnel and make routes towards Saffron harder
#  [X] Handle invalid input()
#  [X] Ensure there are indents for all input() choices only
#  [X] Critical hits
#  [X] Bosses are smarter with move choice
#  [ ] Add super STAB for Normal moves

# TODO: Stretch Features
#  [ ] Add settings to town menu for save/quit and enable/disable tts/vtt
#  [ ] Add option to omit some speech to make game move faster
#  [ ] Add switch training
#  [X] Change all data reads and writes to be for local csv files and not Google Sheets
#  [X] Add TTS instead of print()
#  [X] Add Voice to text instead of input()
#  [X] Add a randomizer mode:
#        [X] Save a Rando seed and settings to Save Data OR a new random Data_Dungeons
#        [X] Add options to randomize when making a new game
#        [X] Monster encounters/Bosses/Starters Rando
#        [ ] Moves Rando
#        [ ] Levels Rando
#        [ ] Steps/Item Chance Rando





# A watered down version of Pokemon that is text based

##############################
#                            #
#           In/Out           #
#                            #
##############################





def voice_print(msg, add_to_buffer=True, end="\n", menu=True):
  global message_buffer
  global speech_mode_out
  global menu_speech_out
  if (speech_mode_out):# or (menu_speech_out or menu)):
    if (add_to_buffer):
      message_buffer += msg + "\n"
      print(msg, end=end)
    engine.say(msg)
    engine.runAndWait()
  else:
    print(msg, end=end)
  return

def voice_input(prompt="", valid_nums=list(range(10)), menu=2):
  prompt += "\n> "
  voice_print(prompt, end="")
  global message_buffer
  global speech_mode_in
  if (speech_mode_in):
    while True:
      r = sr.Recognizer()
      with sr.Microphone() as source:
        while True:
          try:
            audio = r.listen(source, timeout=5)
            break
          except sr.WaitTimeoutError:
            voice_print("Speech timed out. Try again. ", False)
      try:
        result = r.recognize_google(audio, show_all=True)
        if 'alternative' in result:
          transcripts = [alt['transcript'] for alt in result['alternative']]
          text = transcripts[0].split()[0]
          try:
            text_to_num = { "zero":   0, 
                            "one":    1,
                            "two":    2,
                            "three":  3,
                            "four":   4,
                            "five":   5,
                            "six":    6,
                            "seven":  7,
                            "eight":  8,
                            "nine":   9,
                            "repeat": 10}
            num = text_to_num[text]
            if (num == 10):
              # Repeats everything said since last input
              voice_print(message_buffer, False)
              continue
            elif (num in valid_nums):
              # Clears the message_buffer so that everything bewteen this input and the next can be stored there
              message_buffer = ""
              print(num)
              return num
            else:
              raise IndexError
          except (KeyError, ValueError):
            voice_print("Number not recognized: " + text, False)
          except IndexError:
            voice_print("Only inputs of {} are valid. \n".format(valid_nums), False)
        else:
          voice_print("No speech recognized.", False)
      except sr.UnknownValueError:
        voice_print("Sorry, I didn't catch that. Please try again.", False)
      except sr.RequestError:
        voice_print("Sorry, there was an issue with the speech recognition service.", False)
  else:
    prompt = ""
    while True:
      response = input(prompt)
      try:
        num = int(response)
        if (num in valid_nums):
          return num
        prompt = "> "
        raise IndexError
      except IndexError:
        voice_print("Only inputs of {} are valid. \n".format(valid_nums), False)
      except ValueError:
        voice_print("Invalid input. Please enter the number of the choice you would like to select. \n", False)
        


def load():
  player_file_path = os.path.join(game_dir, 'Data_Save_Data.csv')
  with open(player_file_path, 'r') as file:
    Player_rows = csv.reader(file)
    Player_rows = list(Player_rows)
    party_data = Player_rows[:3]
    seed = int(Player_rows[7][0])
    for row in Player_rows:
      while row and row[-1] == "":
        row.pop()
    player = Player(party_data,
                    Player_rows[3][0],
                    Player_rows[4],
                    Player_rows[5],
                    Player_rows[6], 
                    seed)
    if (seed != -1):
      randomize_species(seed)
    return player
  


##############################
#                            #
#            MAIN            #
#                            #
##############################



def main():
  """
  The main function that starts and ends the game.
  It also controls the flow between towns and dungeons.
  """
  print("Enable Speech Mode?")
  num = voice_input("\t1. Audio Output only\n\t2. Voice Input only\n\t3. Audio Output and Voice Input\n\t4. All text", [1,2,3,4])
  global speech_mode_out
  global menu_speech_out
  global speech_mode_in
  speech_mode_out = ((num == 1) or (num == 3))
  menu_speech_out = speech_mode_out
  speech_mode_in =  ((num == 2) or (num == 3))
  voice_print("Starting game ...")
  num = voice_input("\t1. Load Game\n\t2. New Game", [1,2])
  if (num == 1):
    voice_print("Loading game data ...")
    player = load()
    voice_print("Data loaded successfully!")
  elif (num == 2):
    voice_print("Would you like to randomize?")
    num = voice_input("\t1. Yes\n\t2. No", [1,2])
    seed = -1
    if (num == 1):
      seed = r.randint(0, 9999)
      randomize_species(seed)
      voice_print("Game randomized successfully!")
    player = Player(seed=seed)
    voice_print("Beginning your adventure ...\n")
  location = player.location
  run = True
  while (run):
    if (location in Towns):
      location, run = goto_town(player, location)
    elif (location in Dungeons):
      location, run = goto_dungeon(player, location)
    else:
      voice_print("Location {} not found. Last town is {}. ".format(location, player.last_town))
      voice_print("Exiting game ...")
      run = False
  voice_print("Exiting game ...")
  return





##############################
#                            #
#            TOWN            #
#                            #
##############################



def goto_town(player, town_name):
  """
  Lets the player choose what they would like to do in the town.
  They can travel to the next dungeon, check their party summary,
  switch the order of their party, or fast travel to another location.
  Returns the name of the next dungeon to travel to.
  Will continue to loop until a name is given, other wise the result is always -1.
  """
  player.location = town_name
  player.last_town = town_name
  if (Towns[town_name].fly and town_name not in player.fly_list):
    player.fly_list.append(town_name)
  player.heal(1)
  result = -1
  while result == -1:
    result = -1
    voice_print("You are in {}".format(town_name))
    num = voice_input("\t1. Travel\n\t2. Summary\n\t3. Switch\n\t4. Fly\n\t5. Settings\n\t9. Exit\n\t0. Save", [1,2,3,4,5,9,0],1)
    options = [travel, town_summary, town_switch, fly, settings]
    if (num == 0):
      result = player.save()
    elif (num == 9):
      voice_print("Are you sure you want to Exit?")
      exit_num = voice_input("\t1. Back\n\t0. Exit", [1,0])
      if (exit_num == 0):
        return 1, False
      result = -1
    else:
      result = options[num - 1](player)
  return result, True

def travel(player):
  """
  This lists the options of which dungeon to travel to.
  Returns the name of the dungeon selected, or -1 if back is selected.
  """
  town = Towns[player.location]
  voice_print("Here are your travel options:")
  message = ""
  for i in range(len(town.dungeons)):
    message += "\t{}. {}\n".format(i + 1, town.dungeons[i])
  back_num = len(town.dungeons) + 1
  message += "\t{}. Back".format(back_num)
  num = voice_input(message, list(range(1,back_num + 1)))
  options = town.dungeons + [-1]
  dungeon_choice = options[num - 1]
  if (dungeon_choice == "League 1" and len(player.badges) < 8):
    voice_print("You need {} more badges to challenge the League!".format(8 - len(player.badges)))
    return -1
  return dungeon_choice

def party_summary(player):
  msg = ""
  for i in range(len(player.party)):
    mon = player.party[i]
    msg += "\t{}. ".format(i + 1)
    msg += mon.read_summary() + "\n"
  return msg

def town_summary(player):
  player.show_badges()
  msg = party_summary(player)
  back_num = len(player.party) + 1
  msg += "\t{}. Back".format(back_num)
  num = voice_input(msg, list(range(1,back_num + 1)))
  if (num != back_num):
    voice_print(player.party[num - 1].read_moves())
  return -1

def town_switch(player):
  player.switch()
  return -1

def fly(player):
  if (len(player.fly_list) == 0):
    voice_print("You cannot fly anywhere yet. \n")
    return -1
  voice_print("You can fly to the following locations:")
  msg = ""
  for i in range(len(player.fly_list)):
    msg += "\t{}. {}\n".format(i + 1, player.fly_list[i])
  msg += "\t0. Back"
  num = voice_input(msg, list(range(len(player.fly_list) + 1)))
  if (num == 0):
    return -1
  town_name = player.fly_list[num - 1]
  return town_name

def settings(player):
  global speech_mode_out
  global menu_speech_out
  global speech_mode_in
  prompt = "Switch voice modes: \n"
  prompt += "\t1. Toggle master speech\n"
  prompt += "\t2. Toggle menu speech\n"
  prompt += "\t3. Toggle master voice in\n"
  prompt += "\t4. Back"
  num = voice_input(prompt, [1,2,3,4],2)
  if (num == 1):
    speech_mode_out = not speech_mode_out
    menu_speech_out = (speech_mode_out == True)
  if (num == 2):
    menu_speech_out = not menu_speech_out
    speech_mode_out = speech_mode_out or menu_speech_out
  if (num == 3):
    speech_mode_in = not speech_mode_in
  print(speech_mode_out, menu_speech_out, speech_mode_in)
  return -1










##############################
#                            #
#          DUNGEON           #
#                            #
##############################


def goto_dungeon(player, dungeon_name):
  dungeon = Dungeons[dungeon_name]
  last_location = player.location
  player.location = dungeon.name
  dungeon.progress = 0
  while dungeon.progress < dungeon.steps and not player.is_blacked_out():
    voice_print("You are in {} and have made {} out of {} steps. \n".format(dungeon.name, dungeon.progress, dungeon.steps))
    encounter(player, dungeon)
  if (player.is_blacked_out()):
    return player.last_town, True
  if (dungeon.boss is not None and dungeon.name not in player.bosses_beaten):
    voice_print("Boss appears!!!\n\n")
    result = battle(player, dungeon, dungeon.boss)
    if (result == 1):
      player.bosses_beaten.append(dungeon.name)
      if (dungeon.badge != ""):
        player.badges.append(dungeon.badge)
        voice_print("You earned the {} badge!".format(dungeon.badge))
    elif (result == 2):
      return player.last_town, True
  next_location = dungeon.other_entrance(last_location)
  voice_print("{} complete!\n".format(dungeon.name))
  return next_location, True

def encounter(player, dungeon):
  result = 1
  if (r.random() <= dungeon.item_chance):
    voice_print("You have found a potion! Party health restored!")
    player.heal(.2, False)
  else:
    battle(player, dungeon, dungeon.generate_encounter())
  dungeon.progress += 1
  return result

def battle(player, dungeon, foe):
  global speech_mode_out
  if (speech_mode_out):
    divider = " out of "
  else:
    divider = "/"
  owner = "wild " if foe.catchable else "Trainer's "
  voice_print("You encountered a {}Level {} {}!".format(owner, foe.level, foe.name))
  result = -1
  while result == -1:
    msg = "Foe {} has {:>}{}{:<} health remaining. Your {} has {:>}{}{:<} health remaining."
    msg = msg.format(foe.name, foe.curr_hp, 
                     divider, foe.stats["Health"], 
                     player.party[0].name, player.party[0].curr_hp, 
                     divider, player.party[0].stats["Health"])
    voice_print(msg)
    num = voice_input("\t1. Attack\n\t2. Summary\n\t3. Switch", [1,2,3], 2)
    options = [pick_move, dungeon_summary, battle_switch]
    result = options[num - 1](player, foe, owner)
  if (result == 2):
    return 2
  exp = foe.yield_exp()
  player.give_exp(exp)
  player.catch(foe)
  return 1

def pick_move(player, foe, owner):
  voice_print("Select a move:")
  mon = player.party[0]
  message = ""
  for i in range(len(mon.moves)):
    message += "\t{}. {}\n".format(i + 1, mon.moves[i])
  back_num = len(mon.moves) + 1
  message += "\t{}. Back".format(back_num)
  num = voice_input(message, list(range(1,back_num + 1)))
  if (num == back_num):
    return -1
  return attack(player, mon, foe, mon.moves[num - 1])

def attack(player, mon, foe, move_name1, skip_player=False):
  move_name2 = foe.select_move(mon)
  fast = (foe, move_name2, "Foe ", "")
  slow = (mon, move_name1, "", "Foe ")
  if (not skip_player and foe.stats["Speed"] < mon.stats["Speed"]):
    fast = (mon, move_name1, "", "Foe ")
    slow = (foe, move_name2, "Foe ", "")
  slow[0].inflict_damage(fast[0], Moves[fast[1]], fast[2], fast[3])
  if (mon.curr_hp == 0):
    voice_print("{} fainted!\n".format(mon.name))
    if (player.is_blacked_out()):
      voice_print("You blacked out! You scurry to the last town to escape further harm. \n")
      return 2
    result = -1
    while result == -1:
      result = death_switch(player)
    return -1
  if (foe.curr_hp == 0):
    voice_print("Foe {} fainted!\n".format(foe.name))
    return 1
  if (not skip_player):
    fast[0].inflict_damage(slow[0], Moves[slow[1]], slow[2], slow[3])
  if (mon.curr_hp == 0):
    voice_print("{} fainted!\n".format(mon.name))
    if (player.is_blacked_out()):
      voice_print("You blacked out! You scurry to the last town to escape further harm. ")
      return 2
    result = -1
    while result == -1:
      result = death_switch(player)
    return -1
  if (foe.curr_hp == 0):
    voice_print("Foe {} fainted!\n".format(foe.name))
    return 1
  return -1

def dungeon_summary(player, foe, owner=""):
  msg = "\t   {}\n".format(foe.read_summary(owner))
  msg += party_summary(player)
  back_num = len(player.party) + 1
  msg += "\t{}. Back".format(back_num)
  num = voice_input(msg, list(range(1,back_num + 1)))
  if (num == back_num):
    return -1
  else:
    voice_print(player.party[num - 1].read_moves())
    return -1

def battle_switch(player, foe, owner):
  if (player.switch() == 1):
    return attack(player, player.party[0], foe, "", True)
  return -1

def death_switch(player):
  return player.switch()























#############################
#                           #
#   CLASSES AND CONSTANTS   #
#                           #
#############################


# A Town is a rest stop between Dungeons. Some will have gyms or rocket areas
#  that are self contained. Towns will fully heal you and let you switch out
#  party members. Towns with gyms can be flown to.
class Town:
  def __init__(self, name):
    self.name = name
    self.fly = False
    self.dungeons = []

  def enable_fly(self):
    self.fly = True

  def add_dungeon(self, dungeon):
    if (self.name == "Credits"):
      return
    self.dungeons.append(dungeon)


# Town Data
town_file_path = os.path.join(game_dir, 'Data_Towns.csv')
with open(town_file_path, 'r') as file:
  reader = csv.reader(file)
  next(reader)  # Skip the header row if present
  Towns = {}
  for town_row in reader:
    town_name = town_row[0]
    town = Town(town_name)
    if (town_row[1] == "Yes"):
      town.enable_fly()
    Towns[town_name] = town





# A Monster is a template for a single kind of Monster. The element is a list of one
#  or two Pokemon elements. This will also list what moves they learn and when,
#  their base stats, and evolutions level and name.
class Monster_Species:
  def __init__(self, num, name, elements, base_stats, exp_yield, evo_lv, evo_name, moves):
    #num, name, elements, base_stats, evo_lv, evo_name, moves = args
    self.num = int(num)
    self.name = name
    self.elements = elements
    if (len(elements) > 1 and elements[1] == ""):
      elements.pop()
    self.base_stats = {"Health"  : int(base_stats[0]),
                       "Attack"  : int(base_stats[1]),
                       "Defense" : int(base_stats[2]),
                       "Speed"   : int(base_stats[3])}
    self.exp_yield = int(exp_yield)
    self.evolution_lv = 0
    if (evo_lv != ""):
      self.evolution_lv = int(evo_lv)
    self.evolution_name = evo_name
    self.add_moves(moves)

  def add_moves(self, moves):
    while (moves and moves[-1] == ""):
      moves.pop()
    self.moves = moves

  def scale_stats(self, scale=1):
    scale = int(scale * (400 / sum(self.stats.values())))
    self.base_stats = {"Health"  : scale * self.base_stats["Health"],
                       "Attack"  : scale * self.base_stats["Attack"],
                       "Defense" : scale * self.base_stats["Defense"],
                       "Speed"   : scale * self.base_stats["Speed"]}

  def template_info(self):
    return [self.num, self.name, self.elements, list(self.base_stats.values()), self.exp_yield, self.evolution_lv, self.evolution_name, self.moves]


# Monster Species Data
species_file_path = os.path.join(game_dir, 'Data_Monsters.csv')
with open(species_file_path, 'r') as file:
  reader = csv.reader(file)
  next(reader)  # Skip the header row if present
  Species = {}
  for species_row in reader:
    species_name = species_row[1]
    species = Monster_Species(species_row[0],
                              species_name,
                              species_row[2:4],
                              species_row[4:8],
                              species_row[8],
                              species_row[9],
                              species_row[10],
                              species_row[11:15])
    Species[species_name] = species

Species_shuffled = Species.copy()

def randomize_species(seed):
  global Species_shuffled
  if (seed == -1):
    return
  shuffled_keys = list(Species.keys())
  shuffled_values = list(Species.values())
  r2 = r.Random(seed)
  r2.shuffle(shuffled_keys)
  r2.shuffle(shuffled_values)
  Species_shuffled = {}
  for i in range(len(shuffled_keys)):
    Species_shuffled[shuffled_keys[i]] = shuffled_values[i]

def get_species(name, randomized):
  # Even if random is true, if this isn't a randomizer then Species_shuffled will be identical to Species
  if (randomized):
    return Species_shuffled[name]
  return Species[name]




# An instance of a Monster with defined stats, a level, and other values unique
#  to an individual Monster.
class Monster(Monster_Species):
  def __init__(self, name, level, exp = 0, catchable=True, randomized=True):
    args = get_species(name, randomized).template_info()
    super().__init__(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7])
    self.level = int(level)
    self.total_exp = (level ** 3) + exp
    self.curr_level_exp = exp
    self.catchable = catchable
    self.stats = {}
    self.update_stats()
    self.curr_hp = self.stats["Health"]
    self.boss = False

  def update_stats(self):
    stat_names = ["Health", "Attack", "Defense", "Speed"]
    for name in stat_names:
      base_stat = self.base_stats[name]
      self.stats[name] = int(2 * base_stat * self.level / 100) + 5
    self.stats["Health"] += self.level + 5

  def read_stats(self, hide_stats=False):
    global speech_mode_out
    if (speech_mode_out):
      divider = " out of "
    else:
      divider = "/"
    hide_stats=False
    if (hide_stats):
      foe_hp_percent = int(100 * self.curr_hp / self.stats["Health"])
      return "HP is {} percent. ".format(foe_hp_percent)
    msg = "HP is {:>3}{}{:>3}, Attack is {:>3}, Defense is {:>3}, Speed is {:>3}, Next Level is {}{}{}"
    exp_needed = int(((self.level + 1) ** 3) - ((self.level) ** 3))
    if (self.level == 100):
      exp_needed = 0
    msg = msg.format(self.curr_hp, divider, 
                     self.stats["Health"], self.stats["Attack"],
                     self.stats["Defense"], self.stats["Speed"],
                     self.curr_level_exp, divider, exp_needed)
    return msg

  def read_summary(self, owner=""):
    msg = "Level {:<3} {}{:<10}"
    msg = msg.format(self.level, owner, self.name)
    return msg

  def read_moves(self):
    msg = "{}: {}".format(self.read_summary(), self.elements[0])
    if (len(self.elements) > 1):
      msg += "/" + self.elements[1]
    msg += "\n" + self.read_stats() + "\n"
    max_move_len = max(len(move_name) for move_name in self.moves)
    max_elem_len = 8
    for i in range(len(self.moves)):
      move = Moves[self.moves[i]]
      msg += "{:<{}}: Elem {:<{}} Pow {:>3}, Acc {:>3}%\n"
      msg = msg.format(move.name,
                       max_move_len,
                       move.element,
                       max_elem_len,
                       move.power,
                       int(move.accuracy * 100))
    return msg

  def find_damage(self, attacker, move):
    base_damage = ((2 * attacker.level / 5 + 2) * move.power * attacker.stats["Attack"] / self.stats["Defense"] / 50) + 2
    effectiveness = 1.0
    if (move.element in attacker.elements):
      effectiveness *= 1.5
    for element in self.elements:
      try:
        effectiveness *= Element_Check[move.element][element]
      except:
        voice_print("Element check failed, atk:{}, def:{}".format(move.element, element))
    if (effectiveness == 0):
      return -1
    return base_damage * effectiveness

  def inflict_damage(self, attacker, move, attacker_owner="", defender_owner=""):
    if (r.random() >= move.accuracy):
      voice_print("{}{}'s attack missed!".format(attacker_owner, attacker.name))
      return
    base_damage = self.find_damage(attacker, move)
    if (base_damage == -1):
      # Move doesn't effect self due to typing
      damage = 0
    else:
      deviation = 1.0 - (0.15 * r.random())
      crit = 1.0
      if (r.random() <= (1 / 16)):
        voice_print("Critical hit! ", end="")
        crit = 1.5
      damage = max(1, int(base_damage * deviation * crit))
    self.curr_hp = max(0, self.curr_hp - damage)
    voice_print("{}{} was hit by {} for {} damage!".format(defender_owner, self.name, move.name, damage))

  def select_move(self, foe):
    # Ranks moves by damage then weights the better moves in its decision
    ranked_moves = sorted(self.moves, key=(lambda move: foe.find_damage(self, Moves[move]) * Moves[move].accuracy))
    power = 2
    if (self.boss):
      # Bosses are more likely to select stronger moves
      power = 3
    index = int(len(self.moves) * (1 - (r.random() ** power)))
    return ranked_moves[index]

  def yield_exp(self):
    easy_exp = 2.0
    return int(easy_exp * self.exp_yield * self.level / 7)

  def add_exp(self, exp):
    self.total_exp += exp
    self.curr_level_exp += exp
    fractional_level = float(self.total_exp) ** (1/3) + 1e-10
    if (min(100, fractional_level) >= self.level + 1):
      self.level = int(fractional_level)
      voice_print("{} leveled up to {}!".format(self.name, self.level))
      self.curr_level_exp = self.total_exp - (self.level) ** 3
      if (self.level == 100):
        self.curr_level_exp = 0
      old_max_hp = self.stats["Health"]
      self.check_evo()
      self.update_stats()
      self.curr_hp += self.stats["Health"] - old_max_hp
      voice_print(self.read_stats())

  def check_evo(self):
    if ((self.evolution_lv != 0) and (self.level >= int(self.evolution_lv))):
      voice_print("Huh? Your {} is evolving?!".format(self.name))
      old_name = self.name
      self.evolve()
      voice_print("Your {} evolved into {}!".format(old_name, self.name))
    return

  def evolve(self):
    evo_name = self.evolution_name
    if (self.name == "Eevee"):
      eeveelutions = ["Vaporeon", "Jolteon", "Flareon"]
      evo_name = eeveelutions[r.randint(0, 2)]
    # Evolutions are also random in a randomizer for now
    evo_species = get_species(evo_name, True)
    self.num, self.name, self.elements, base_stats, self.exp_yield, self.evolution_lv, self.evolution_name, self.moves = evo_species.template_info()
    self.base_stats = {"Health"  : int(base_stats[0]),
                       "Attack"  : int(base_stats[1]),
                       "Defense" : int(base_stats[2]),
                       "Speed"   : int(base_stats[3])}
    return

  def save(self):
    return [self.name, self.level, self.curr_level_exp]




# A Dungeon is just any area with enemies. It can connect one Town to another or
#  be conntained in a single Town. Each one has its own list of enemies that can
#  be encountered as well as a number of steps to pass it. Each step is either
#  an encounter or an item. An item heals 20% of your party's HP.
class Dungeon:
  def __init__(self, name, badge, connection1, connection2, steps, min_lv, max_lv, wild_catchable, encounters, boss_data):
    self.name = name
    self.badge = badge
    self.connections = [connection1, connection2]
    if (connection1 in Towns):
      Towns[connection1].add_dungeon(name)
    if ((connection2 in Towns) and (connection1 != connection2)):
      Towns[connection2].add_dungeon(name)
    self.progress = 0
    self.steps = int(steps)
    self.level_range = [int(min_lv), int(max_lv)]
    self.item_chance = 0.15
    self.add_table(encounters)
    self.wild_catchable = (wild_catchable == "Yes")
    self.add_boss(boss_data)

  def add_table(self, encounters):
    while (encounters and encounters[-1] == ""):
      encounters.pop()
    self.encounter_table = encounters

  def add_boss(self, data):
    if (len(data[0]) == 0):
      self.boss = None
    else:
      boss = Monster(data[0], int(data[1]), catchable=(data[2] == "Yes"))
      boss.boss = True
      self.boss = boss

  def generate_encounter(self):
    index = r.randint(0, len(self.encounter_table) - 1)
    monster_name = self.encounter_table[index]
    level = r.randint(self.level_range[0], self.level_range[1])
    mon = Monster(monster_name, level, catchable=self.wild_catchable)
    return mon

  def other_entrance(self, town_name):
    if (town_name == self.connections[0]):
      return self.connections[1]
    if (town_name == self.connections[1]):
      return self.connections[0]
    return "Error, no {} found, only {} and {}".format(town_name, self.connections[0], self.connections[1])


# Dungeon Data
dungeons_file_path = os.path.join(game_dir, 'Data_Dungeons.csv')
with open(dungeons_file_path, 'r') as file:
  reader = csv.reader(file)
  next(reader)  # Skip the header row if present
  Dungeons = {}
  for dungeon_row in reader:
    dungeon_name = dungeon_row[0]
    dungeon = Dungeon(dungeon_name,
                      dungeon_row[1],
                      dungeon_row[2],
                      dungeon_row[3],
                      dungeon_row[4],
                      dungeon_row[8],
                      dungeon_row[9],
                      dungeon_row[10],
                      dungeon_row[11:18],
                      dungeon_row[5:8])
    Dungeons[dungeon_name] = dungeon




# Specifications for a move to be used by a Monster.
class Move:
  def __init__(self, name, element, power, accuracy):
    self.name = name
    self.element = element
    self.power = int(power)
    self.accuracy = float(accuracy[:-1]) / 100.0

  def read_info(self):
    msg = "{} is a {} element move with power {} and accuracy {}"
    msg.format(self.name, self.element, self.power, int(100 * self.accuracy))
    voice_print(msg)


# Move Data
moves_file_path = os.path.join(game_dir, 'Data_Moves.csv')
with open(moves_file_path, 'r') as file:
  reader = csv.reader(file)
  next(reader)  # Skip the header row if present
  Moves = {}
  for move_row in reader:
    move_name = move_row[0]
    move = Move(move_name,
                move_row[1],
                move_row[2],
                move_row[3])
    Moves[move_name] = move




# Element Effectiveness Data
# Element_Check[element1][element2] gives the damage multiplier for using a move of
#  element1 on an opponent of element2.
elements_file_path = os.path.join(game_dir, 'Data_Type_Table.csv')
with open(elements_file_path, 'r') as file:
  reader = csv.reader(file)
  Element_Check = {}
  type_data = []
  for row in reader:
    type_data.append(row)
  element_names = type_data[0][1:19]
  for i in range(18):
    atk_element = element_names[i]
    row = type_data[i + 1]
    row_dict = {}
    for j in range(18):
      def_element = element_names[j]
      row_dict[def_element] = float(row[j + 1])
    Element_Check[atk_element] = row_dict









##############################
#                            #
#           PLAYER           #
#                            #
##############################



# Data about the Player
class Player:
  def __init__(self, party_data=[], location="Pallet Town", badges=[], fly_list=[], bosses_beaten=[], seed=-1):
    self.party = []
    if (party_data == []):
      starters = ["Charmander", "Squirtle", "Bulbasaur"]
      for mon in starters:
        self.party.append(Monster(mon, 5))
    else:
      for data in party_data:
        self.party.append(Monster(data[0], int(data[1]), exp=int(data[2]), randomized=False))
    self.location = location
    self.last_town = location
    self.badges = badges
    self.fly_list = fly_list
    self.bosses_beaten = bosses_beaten
    self.seed = seed

  def show_badges(self):
    msg = ""
    badge_count = len(self.badges)
    if (badge_count == 0):
      msg += "You don't have any badges yet. \n"
    elif (badge_count == 1):
      msg += "You have 1 badge. \n"
    else:
      msg += "You have {} badges. ".format(badge_count) + "\n"
    for badge in self.badges:
      msg += badge + " Badge  "
    voice_print(msg)

  def heal(self, amount, revive=True):
    for mon in self.party:
      if (revive or mon.curr_hp > 0):
        mon.curr_hp = min(mon.curr_hp + int(amount * mon.stats["Health"]), mon.stats["Health"])

  def is_blacked_out(self):
    for mon in self.party:
      if (mon.curr_hp > 0):
        return False
    return True

  def party_summary(self):
    msg = ""
    for i in range(len(self.party)):
      mon = self.party[i]
      msg += "\t{}. {}\n".format(i + 1, mon.read_summary())
    return msg

  def switch(self):
    if (len(self.party) <= 1):
      voice_print("Only one Monster in party. \n\n")
      return -1
    voice_print("Switch lead to which one?")
    msg = self.party_summary()
    back_num = len(self.party) + 1
    msg += "\t{}. Back".format(back_num)
    num = voice_input(msg, list(range(1,back_num + 1)))
    if (num == back_num):
      return -1
    temp = self.party[num - 1]
    if (temp.curr_hp <= 0):
      voice_print("There is no will to battle. ")
      return -1
    if (num == 1):
      voice_print("{} is already in the lead!".format(self.party[0].name))
      return -1
    self.party[num - 1] = self.party[0]
    self.party[0] = temp
    voice_print("{} is now in the lead. ".format(self.party[0].name))
    return 1

  def give_exp(self, exp):
    exp_fraction = int(exp / 3)
    voice_print("{} gained {} exp points!".format(self.party[0].name, exp))
    self.party[0].add_exp(exp)
    if (self.party[1].curr_hp > 0):
      voice_print("{} gained {} exp points!".format(self.party[1].name, exp_fraction))
      self.party[1].add_exp(exp_fraction)
    if (self.party[2].curr_hp > 0):
      voice_print("{} gained {} exp points!".format(self.party[2].name, exp_fraction))
      self.party[2].add_exp(exp_fraction)
    voice_print(" ")
  
  def catch(self, foe):
    if (not foe.catchable):
      return 0
    voice_print("It's weak! Try catching the {}?".format(foe.name))
    num = voice_input("\t1. Yes\n\t2. No", [1,2])
    if (num == 2):
      return 0
    caught = False
    shakes = 4
    catch_rate = max(0, min(100, 100 - 3 * (foe.level - self.party[0].level)))
    caught = 100 * r.random() <= catch_rate
    if (not caught):
      shakes = r.randint(1, 3)
    for i in range(shakes):
      voice_print("*SHAKE*")
    if (caught):
      voice_print("Congradulations! You caught {}!".format(foe.name))
      while True:# Loops this portion if there is an invalid input
        voice_print("Select a Monster you would like to release:")
        msg = ""
        for i in range(len(self.party)):
          msg += "\t{}. {}\n".format(i + 1, self.party[i].read_summary())
        back_num = len(self.party) + 1
        msg += "\t{}. {}".format(back_num, foe.read_summary())
        num = voice_input(msg, list(range(1,back_num + 1)))
        if (num == back_num):
          return 0
        releasee = self.party[num - 1]
        hp_percent = releasee.curr_hp / releasee.stats["Health"]
        foe.curr_hp = int(hp_percent * foe.stats["Health"])
        voice_print("Goodbye {}!".format(releasee.name))
        self.party[num - 1] = foe
        return 1
    voice_print("Shoot! Looks like they escaped!\n\n")
    return -1

  def save(self):
    # Existing code to prepare the data for saving
    # Read the existing data from the CSV file
    voice_print("Saving...")
    data = []
    for mon in self.party:
      data.append(mon.save())
    data.append([self.location])
    data.append(self.badges)
    data.append(self.fly_list)
    data.append(self.bosses_beaten)
    data.append([self.seed])
    # Add in Header column
    #row_names = ["Mon 1", "Mon 2", "Mon 3", "Location", "Badges", "Fly List", "Bosses Beaten", "seed"]
    #for i in range(len(data)):
    #  row = [row_names[i]]
    #  row.append(data[i])
    # Now save it
    csv_file_path = os.path.join(game_dir, 'Data_Save_Data.csv')
    with open(csv_file_path, 'w', newline='') as file:
      writer = csv.writer(file)
      writer.writerows(data)
    voice_print("Save Complete!")
    return -1
  




main()












